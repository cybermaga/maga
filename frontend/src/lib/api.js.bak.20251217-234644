/**
 * frontend/src/lib/api.js
 * Единая точка для API-клиента фронта.
 * Цель: чтобы сборка НЕ падала на "not exported" и чтобы repo upload работал.
 */

const API_BASE =
  process.env.REACT_APP_API_BASE_URL ||
  process.env.REACT_APP_API_URL ||
  "http://localhost:8000/api";

function joinUrl(path) {
  if (!path) return API_BASE;
  if (path.startsWith("http")) return path;
  // path может быть "/health" или "health"
  const p = path.startsWith("/") ? path : `/${path}`;
  return `${API_BASE}${p}`;
}

async function request(path, opts = {}) {
  const url = joinUrl(path);

  const headers = opts.headers || {};
  const isFormData =
    typeof FormData !== "undefined" && opts.body instanceof FormData;

  // Для FormData НЕ ставим Content-Type вручную
  const finalHeaders = isFormData
    ? headers
    : { "Content-Type": "application/json", ...headers };

  const res = await fetch(url, {
    ...opts,
    headers: finalHeaders,
  });

  const text = await res.text();
  let data;
  try {
    data = text ? JSON.parse(text) : null;
  } catch {
    data = text;
  }

  if (!res.ok) {
    const msg =
      (data && data.detail) ||
      (typeof data === "string" ? data : "Request failed");
    throw new Error(msg);
  }

  return data;
}

/** Helpers used by RepoScanUpload */
export function formatFileSize(bytes) {
  if (!bytes && bytes !== 0) return "";
  const units = ["B", "KB", "MB", "GB"];
  let v = bytes;
  let i = 0;
  while (v >= 1024 && i < units.length - 1) {
    v /= 1024;
    i += 1;
  }
  return `${v.toFixed(i === 0 ? 0 : 1)} ${units[i]}`;
}

export function validateZipFile(file) {
  if (!file) return { valid: false, error: "No file selected" };
  const name = (file.name || "").toLowerCase();
  const isZipByName = name.endsWith(".zip");
  const isZipByType =
    file.type === "application/zip" || file.type === "application/x-zip-compressed";

  if (!isZipByName && !isZipByType) {
    return { valid: false, error: "Please select a .zip file" };
  }

  const max = 100 * 1024 * 1024; // 100MB
  if (file.size > max) {
    return { valid: false, error: "ZIP file is too large (max 100MB)" };
  }

  return { valid: true, error: "" };
}

/**
 * Repo scan API (то, что нужно кнопке Upload & Scan)
 * Бекенд ждёт ИМЕННО поля: zip_file и system_name
 */
export const repoScanAPI = {
  uploadAndScan: (zipFile, systemName, onProgress) =>
    new Promise((resolve, reject) => {
      try {
        const fd = new FormData();
        fd.append("zip_file", zipFile);
        fd.append("system_name", systemName);

        const xhr = new XMLHttpRequest();
        xhr.open("POST", joinUrl("/compliance/scan/repo"));

        xhr.upload.onprogress = (evt) => {
          if (!evt.lengthComputable) return;
          const percent = Math.round((evt.loaded / evt.total) * 100);
          if (typeof onProgress === "function") onProgress(percent);
        };

        xhr.onload = () => {
          try {
            const ok = xhr.status >= 200 && xhr.status < 300;
            const payload = xhr.responseText ? JSON.parse(xhr.responseText) : null;
            if (!ok) {
              const msg =
                (payload && payload.detail) ||
                xhr.responseText ||
                `Upload failed (${xhr.status})`;
              return reject(new Error(msg));
            }
            resolve(payload);
          } catch (e) {
            reject(e);
          }
        };

        xhr.onerror = () => reject(new Error("Network error during upload"));
        xhr.send(fd);
      } catch (e) {
        reject(e);
      }
    }),

  getResult: (id) => request(`/compliance/scan/repo/${id}`, { method: "GET" }),
};

/**
 * Artifacts uploader — чтобы не падала сборка (ArtifactUploader.js)
 * Ожидаемый контракт: artifactsApi.upload(file, type, scanId?)
 */
export const artifactsApi = {
  upload: async (file, type, scanId) => {
    const fd = new FormData();
    fd.append("file", file);
    fd.append("type", type);
    if (scanId) fd.append("scan_id", scanId);

    return request("/artifacts/upload", {
      method: "POST",
      body: fd,
    });
  },

  list: async () => request("/artifacts", { method: "GET" }),
};

/**
 * Evidence API — чтобы не падала сборка (EvidenceTab.js)
 * EvidenceTab ожидает: getEvidence, runAnalyzers, getRawEvidence
 * Если бэкенд пока не реализовал эти урлы — будет runtime 404, но сборка пройдет.
 */
export const evidenceApi = {
  getEvidence: async (scanId) =>
    request(`/evidence/${scanId}`, { method: "GET" }),

  runAnalyzers: async (scanId, analyzers) =>
    request("/evidence/run", {
      method: "POST",
      body: JSON.stringify({ scan_id: scanId, analyzers }),
    }),

  getRawEvidence: async (scanId, evidenceId) =>
    request(`/evidence/${scanId}/raw/${evidenceId}`, { method: "GET" }),
};

/**
 * complianceApi — чтобы не падала сборка (кто-то импортирует complianceApi)
 * Даем минимальный фасад.
 */
export const complianceApi = {
  health: async () => request("/health", { method: "GET" }),

  repoScan: async (zipFile, systemName, onProgress) =>
    repoScanAPI.uploadAndScan(zipFile, systemName, onProgress),

  getRepoScan: async (id) => repoScanAPI.getResult(id),
};

/**
 * Чтобы не падал Dashboard, если он ожидает getReports
 * Если эндпоинта нет — будет runtime ошибка, но сборка пройдет.
 */
export async function getReports() {
  return request("/reports", { method: "GET" });
}
// systemAPI — минимальный фасад, чтобы сборка не падала
export const systemAPI = {
  // если у бэка есть эндпоинт систем/сканов — сюда привяжем
  list: async () => request("/systems", { method: "GET" }),
  get: async (id) => request(`/systems/${id}`, { method: "GET" }),
};
